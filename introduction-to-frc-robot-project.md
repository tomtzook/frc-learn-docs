
## Retreiving Template

Because creating a robot project is a bit complex, and Intellij does not provide this capability in its project creator, we use a pre-made template which is fully configured and ready to use.
As such, to open a new robot project, one needs to download this template and open it.

Open [this page](https://github.com/Flash3388/Frc-Robot-Template). 

Click on the green _Code_ button. 

![code button](https://github.com/user-attachments/assets/18735399-f4f1-4251-816a-3b593717d1b5)

This will open a menu, click on _Download Zip_

![download zip](https://github.com/user-attachments/assets/efd7de12-e3fc-45c8-968d-d90ab8cd7fb0)

This will download a `.zip` file with the template. Once the download has finished, open the file and extract the folder inside
to a location of your choosing on the computer.

It is recommended to create a specialized folder for all your robot project in a location you will remember. It is also recommended to rename
the extract folder to something unique, so you could easily understand what it is. This name typically should reference what robot you are working on.

> [!WARNING]
> Do not place these folders under OneDrive if you have one. This will fuck up the project files.

Once the folder was placed, open _Intellij_ and open this new project via _File->Open_. This will open a folder selection dialog, navigate to the folder you extracted, select it and click _Ok_ to open the project.

![file open](https://github.com/user-attachments/assets/f054ae2a-1538-4836-8557-2c9f3956b19a)

> [!NOTE]
> For newer intellj versions, this _File_ menu is hidden. Click on the Hamburger button on the top left to show it.

![file open dialog](https://github.com/user-attachments/assets/234fcb91-042b-4e30-8763-4dfa968567f7)

> [!NOTE]
> Make sure you are selecting the folder you extracted and not a part of it or the folder containing it.

Once selected, the project will start loading. This may take a few minutes. You will notice a loading bar in the bottom of Intellij.
Let it finish before using the project.

## Robot Project Structure

![project view](https://github.com/user-attachments/assets/2890e310-a54d-4a67-b26e-3d62bf0abb86)

As you can see, even an _empty_ robot project is packed with many things. 

To start, it should be noted that robot projects use the [_Gradle_](https://gradle.org/) build tool. Build tools are responsible for build code (mainly compiling but can do more than that). Basic projects in Intellij typically use Intellij as a build tool, but it is a very limited tool. _Gradle_, however, is a popular build tool for Java, and quite powerful. We will not be learning about _Gradle_ here, but this explains why the project looks so different.

The files and folders related to gradle are
- `gradle/` _Gradle_ run binary folder
- `.gradle/`: _autogenerated_ folder containing build information
- `gradlew.bat`: windows _Gradle_ run script
- `gradlew`: unix _Gradle_ run script
- `build.gradle`: build configuration
- `settings.gradle`: project configuration

Because this is an FRC project, there are several files and folders specific for FRC use:
- `.wpilib/`: _WPILib_ project configuration
- `vendordeps/`: _WPILib_ and third-party libraries declerations

> [!WARNING]
> Do not touch any of the files/folders mentioned above unless you know what you are doing. This could easily break the project.

The code itself is located under `src/main/java`. You will notice it has both several packages and _Java Class_ files. In here we will write our robot code.

> [!NOTE]
> All code files should be under the `frc.robot` package

The `build` folder is autogenerated (when running the build) and contains the compiled code. Do not touch this. Though, deleting this folder is fine as it will be recreated.

> [!NOTE]
> When copying the project between computers, you should not copy `.idea`, `.gradle` and `build` folders. These are autogenerated and somewhat computer-specific.

## Robot Code

![robot code files](https://github.com/user-attachments/assets/4bd559c1-7c7d-46fe-8362-3e8f81422033)

You will notice that the project comes with several code files. These are necessary, and contain the base structure for robot code.

### Main

Like any Java project, robot projects require an entry point (`main` method) as well. This is provided by the `Main` class.

```java
package frc.robot;

import edu.wpi.first.wpilibj.RobotBase;

public class Main {

    public static void main(String[] args) {
        RobotBase.startRobot(Robot::new);
    }
}
```

This _main_ starts the _WPILib_ robot code framework. 

> [!WARNING]
> Changing this may break the robot code

### Robot

For all intent and purpose, the `Robot` class serves as our _main_. All our robot code will be constructed here. This class has a pretty intersting structure, and comes with methods ready for use. This is intentional, as each method has a specific purpose.

```java
package frc.robot;

import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj2.command.CommandScheduler;

public class Robot extends TimedRobot {

    @Override
    public void robotInit() {

    }

    @Override
    public void disabledInit() {

    }

    @Override
    public void disabledPeriodic() {

    }

    @Override
    public void teleopInit() {

    }

    @Override
    public void teleopPeriodic() {

    }

    @Override
    public void autonomousInit() {

    }

    @Override
    public void autonomousPeriodic() {

    }

    @Override
    public void testInit() {

    }

    @Override
    public void testPeriodic() {

    }

    @Override
    public void robotPeriodic() {
        CommandScheduler.getInstance().run();
    }

    @Override
    public void simulationPeriodic() {

    }
}
```

The robot code operates as a huge loop. This loop runs behind the scenes and calls the methods in `Robot` class depdending on the current state of the robot. As such, when we want to write a code for the robot, we must place the code in the appropriate method, so that it will run during a specific robot state.

This loop, is divided into several modes:
- _disabled_: safety mode. The robot should do nothing here.
- _teleop_ (tele-operated): Robot is operated by a human with some controller/gamepad.
- _autonomous_: Robot is operated without a human, i.e. it must decide on its own what to do.
- _test_: Generic state to test parts of the robot. A useful utility.

Each mode has two methods attached to it: `init` and `periodic` (e.g. `autonomousInit`, `autonomousPeriodic` for _autonomous_ mode). The `init` method is called when the robot enters this mode (controlled remotely from the _DriverStation_). `periodic` is called every $20ms$ by the robot loop while the robot is in that mode. There is also the possibility to add the `exit` method (for each mode, e.g. `autonomousExit`). 

There are also several other methods:
- `robotInit` is called when the robot code is ready to start running. Should be used to initialize the robot for use (we will see how later). Do not use the `Robot` constructor or initialize members inline, use `robotInit`.
- `robotPeriodic` is called every $20ms$ while the robot is running, no matter the mode
- `simulationPeriodic` is called every $20ms$ while the robot is running, no matter the mode, only when the robot is in simulation mode (we will not learn about this here).

Notice that all the methods discussed use the `@Override` annotation, and that the `Robot` class _extends_ `TimedRobot`. Basically, `TimedRobot` is running the robot loop and defines those methods. As such, their signature cannot be changed, and adding new methods will not make them run in the loop magically.

We can imagine a pseudo code for the robot loop as something like this:
```java
// start of loop
initializeRobotStuff();
robotInit(); // our code

lastMode = disabled;
while (robotIsRunnning) {
  currentMode = getCurrentMode(); // get current mode from DriverStation

  if (lastMode != currentMode) {
    // mode was changed

    // call exit methods
    switch(lastMode) {
      case disabled:
        disabledExit(); // our code
        break;
      case teleop:
        teleopExit(); // our code
        break;
      case autonomous:
        autonomousExit(); // our code
        break;
      case test:
        testExit(); // our code
        break;
    }

    // call init methods
    switch(currentMode) {
      case disabled:
        disabledInit(); // our code
        break;
      case teleop:
        teleopInit(); // our code
        break;
      case autonomous:
        autonomousInit(); // our code
        break;
      case test:
        testInit(); // our code
        break;
    }

    lastMode = currentMode;
  }

  // call periodic method
  switch(currentMode) {
    case disabled:
      disabledPeriodic(); // our code
      break;
    case teleop:
      teleopPeriodic(); // our code
      break;
    case autonomous:
      autonomousPeriodic(); // our code
      break;
    case test:
      testPeriodic(); // our code
      break;
  }

  robotPeriodic(); // our code
  if (robotInSimulation()) {
    simulationPeriodic(); // our code
  }

  sleep(20); // wait 20 ms
}
```

Of course, this is just a pseudo code, but it illustrates the idea of the robot loop.

Typically, when working on a specific mode, we would use the `init` method to initialize operations for that mode. We would use `periodic` to perform the main logic of the mode, and we would use `exit` to stop/deinitialize operations for the mode. 

The selection of which mode to write code for depends on the code. Code intended for human-operator use will be placed in `teleop` methods. Code intended for robot autonomous mode will be placed in `autonomous` method. Recall that the game is divided into $2:15$ minutes of _teleop_ and $0:15$ minutes of _autonomous. 

### RobotMap

`RobotMap` is a simple utility class. We typically place constants in it so that we have an organized location to find all constants.

```java
package frc.robot;

public class RobotMap {

  // example constant
  public static final double ROBOT_LENGTH_METERS = 0.5; // 50 cm

}
```



